// Code generated by go run ./gen.go; DO NOT EDIT.

// Package input contains functionality for handling the CLi input
package domain

import (
	"os"
	"strconv"
	"strings"

	"github.com/jessevdk/go-flags"
	"github.com/sethvargo/go-githubactions"

	"dburriss/impilo_gh/slices"
)

// ActionInputOpts represents schema of action.yaml for generating input for arguments
type ActionInputOpts struct {
	
	ProjectName string `long:"project-name" description:"Name of the project Default: app" default:"app" env:"INPUT_PROJECT-NAME"` 
	ConfigFile flags.Filename `long:"config-file" description:"Config file. Default: impilo.yml Default: impilo.yml" default:"impilo.yml" env:"INPUT_CONFIG-FILE"` 
	UseConfigFile bool `long:"use-config-file" description:"Ignore any config file"` 
	TargetDirectory string `long:"target-directory" description:"Directory where the project file is found" default:"" env:"INPUT_TARGET-DIRECTORY"` 
	PackageManager string `long:"package-manager" description:"Package manager eg. npm, nuget Default: npm" default:"npm" env:"INPUT_PACKAGE-MANAGER"` 
	SkipScanVulnerabilities bool `long:"skip-scan-vulnerabilities" description:"Vulnerabilities should be scanned"` 
	ScanLicenses bool `long:"scan-licenses" description:"Licenses should be scanned"` 
}

// Initialize a new ActionInputOpts
func NewActionInputOpts() ActionInputOpts {
	return ActionInputOpts{
		
		ProjectName: "app",
		ConfigFile: "impilo.yml",
		UseConfigFile: false,
		TargetDirectory: "",
		PackageManager: "npm",
		SkipScanVulnerabilities: false,
		ScanLicenses: false,
	}
}

// ActionInput represents values from the arguments
type ActionInput struct {
	
	ProjectName string 
	ConfigFile string 
	UseConfigFile bool 
	TargetDirectory string 
	PackageManager string 
	SkipScanVulnerabilities bool 
	ScanLicenses bool 
}

// Convert ActionInputOpts to ActionInput
func (opts ActionInputOpts) AsActionInput() ActionInput {
	input := ActionInput{
		
		ProjectName: opts.ProjectName,
		ConfigFile: string(opts.ConfigFile) ,
		UseConfigFile: opts.UseConfigFile,
		TargetDirectory: opts.TargetDirectory,
		PackageManager: opts.PackageManager,
		SkipScanVulnerabilities: opts.SkipScanVulnerabilities,
		ScanLicenses: opts.ScanLicenses,
	}
	return input
}

// NewActionInput creates a new ActionInput instance from CLi args
func NewActionInput(args []string) ActionInput {
	// TODO: delete from template
	println("Env Inputs:")
	for _, envS := range os.Environ() {
		vs := strings.Split(envS, "=")
		k := vs[0]
		v := vs[1]
		println(k, v)		
	}

	opts := ActionInputOpts{}
	parser := flags.NewParser(&opts, flags.HelpFlag)
	_, err := parser.ParseArgs(args)
	if err != nil {
		if !flags.WroteHelp(err) {
			panic(err)
		}
	}
	
	if !slices.SliceContains(args, "--use-config-file") {
		key := "use-config-file"
		value := githubactions.GetInput(key)
		println("INPUT use-config-file from action is: ", value, " with length ", len(value))
		if value != "" {
			tmp,bErr := strconv.ParseBool(value)
			if bErr == nil {
				opts.UseConfigFile = tmp 
			}
		}
	}
	if !slices.SliceContains(args, "--skip-scan-vulnerabilities") {
		key := "skip-scan-vulnerabilities"
		value := githubactions.GetInput(key)
		println("INPUT skip-scan-vulnerabilities from action is: ", value, " with length ", len(value))
		if value != "" {
			tmp,bErr := strconv.ParseBool(value)
			if bErr == nil {
				opts.SkipScanVulnerabilities = tmp 
			}
		}
	}
	if !slices.SliceContains(args, "--scan-licenses") {
		key := "scan-licenses"
		value := githubactions.GetInput(key)
		println("INPUT scan-licenses from action is: ", value, " with length ", len(value))
		if value != "" {
			tmp,bErr := strconv.ParseBool(value)
			if bErr == nil {
				opts.ScanLicenses = tmp 
			}
		}
	}

	return opts.AsActionInput()
}